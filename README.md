# condition

https://www.bam.tech/article/how-to-create-a-custom-lint-in-flutter-with-custom-lints
To understand private class:
https://stackoverflow.com/questions/53495089/dart-should-the-instance-variables-be-private-or-public-in-a-private-class
TO DO: NOW FOCUSING ON:
CREATE, UPDATE AND THE REST ON GLOBAL SERVER
======
Snap aspec


=====
For now :
It is basically assumed that local server works in all circumstances and on update failed a model itself tries to reupdate itself in the db. but:
But: For Global server only: Focus on create and update only:
FOCUS ON MODEL ONE TIME GLOBAL CREATE/UPDATE, THEN CYCLICAL STUFF, AS BOTH DESCRIBED BELOW
1. A model after being sent locally to db fully with id returned, etc. or model updated.
2. It just sends itself to global db. You get server_id probably server creation/ update date. Maybe anything else.
    You make sure to_be_synchronized is set to false
3. !!! But On fail async exception/or future.catchError, etc. property to_be_synchronized stays 1 (corresponding to true).
4. Now we have to check on any failed synchronization attempt. 
    a: If one occured we set a "flag" on global driver = true and start an almost immediate
        one time! Timer (maybe something recursive) that checks the db for to_be_synchronized = 1 rows 
        - (after a month you want to check the server value first). 
    b: And then you make the map of model names or something and id to be synchronized
        in the meantime and you update just the list - in the meantime a model may try to synchronize like in 1. 2. points 
        you don't care 
        BUT: this time you cannot create new to_be_synchronized = 1 list read further
    c: You set flag = 0 - only a new problem can fire the flag to true, which you check at the end of the cycle.
    d: You try to synchronize - because of possible problems after we but experenced one - we check one model at a time 
        Remembering that we use the same table for global server and local server and that each server is both local and global
        technically:
        - before we start one thing to mention not create/update when you have two applications one app_id must be used for update
          the second has link on it's device - not a copy, when you edit on one -
            the second must check for changes cyclically:
               : but when you changed something in you app the change is sent to the global server without prior checking for
                 changes, why? Because you may sent an emergency message - cyclical checking for changes should normally
                 do the job - we speak about updating not synchronizing using creating a record in the db
               : later to do: some other users could have rights to edit some tasks or messages, they too edit the same record
                but, but have link to it on their list.
        - you read all the record from the db (later To do: or later you contact the model if it still exists in the app - you update 1 changed field for example, if not exist you read the field from the db) 
        - you sent the the record to the global server "as is" not nowing which fields were changed
        - the global server must recreate model to validate the data, being careful and rethinking the process we 
          use also local_id which is the same as id on the local server - see the field description
        - based on field properties like "app_only" "both_app_and_server_synchronized" global server should decide what to put 
          to the db record
        - having update the server don't throw error optionally we have server_one_time_insertion_key on create and create/update dates to confirm the data is synchronized


========================================================================================



See if @protected set id_protected(int? value) of [ConditionModelIdAndOneTimeInsertionKeyModel] throws an error, as it is exptected to, on an assignement attempt. Also anywhere else.

Important! Is List always passed by reference [ConditionDataManagementDriverQueryBuilderPartWhereClause] in preparing possible long sql statements from Lists might cause existing up to two long Lists. I treat it as reference to the same object in a function

Found also official wasm file and js api https://www.sqlite.org/download.html but it uses localstorage, so not usable. But there are libraries you
have to have for android, windows, linux, mac, android - i use 64-bit library for windows for now.
Ugly important - For all data operations on db one universal sql syntax must to be used so it means object of [ConditionDataManagementDriver] class are to use it. Then after the app and libraries are well established some optimization classess can be made but with not changing the original ones. Those optimised classess can f.e. extend like ...Sqlite3Optimised or whatever. All the stuff is here to be multiplatform, multi db engines, multi server techniques like dart, php. 
under the hood everywhere sql is used to store data. Probably, for every future
db driver in the app, including based on mysql, postgres, etc. Sqlite and probably approximately sql92 syntax will be used. Bear especially in mind that you cannot (you probably could, but it is strongly discouraged for availability) use queries incompatible with
sqlite/websql and similar sqlite approaches like duckDB (implementation planned), but also with sqlweb github library (based on isstore (github) engine that in turn uses indexedDB storage). However some of the sqlite syntax is translated to sqlweb when it is used instead of websql that can be turned off in the not long future (translated is: insert, create database). Many queries in sqlweb library seem to be compatible with standard sql and sqlite in general. If possible use php adminer script to export database into sql, and in turn in js all queries are translated to sqlweb sql dialect. You can't use (at the moment of writing) column names in any kind of quotes (which may change in the future).
huge imact on sqlite performance (transactions) i don't predict to implement transactions any time soon, but i will have to: https://stackoverflow.com/questions/1711631/improve-insert-per-second-performance-of-sqlite?rq=1
----------------------------

How to run or build not with main.dart, but any other file.dart:
https://stackoverflow.com/questions/55510244/flutter-how-do-i-change-main-dartentry-point-to-some-other-page-in-flutter
flutter run -t lib/my_other_main.dart
flutter build apk -t lib/config/main_production.dart

Simplified all architecture - update. For web and native (f.e. windows, android) you do everything connecting to a local http server - it is you database (for web this server is emulated and works exactly the same way like in native). Your local server consists of two aspects: local server (bluetooth, local wifi with ip 192.168, etc) and global - when client devices connect to your global i.p. if you have any. ###!!! YOU NEED TO UNDERSTAND ABOVE AND BELOW AND DO ONLY THE GLOBAL ASPECT, PREPARING AND NOT DAMAGING THE CONNECTION TO A SECOND DEVICE WITH IT'S OWN SERVER - ANALYZE ALL WRITTEN HERE - NOT A SIMPLE THING### So starting from the top the architecture with data look like this: you local server automatically has a unique key you get from the earthwide global server and this key is related to id of your application on the global server. Any user registered in you local server belongs to this global app id. Your app (See [ConditionModelUser] class) registers user or more users, a connected device registers his user on your local server (the mentioned unique key with no password or in case someone reinstalled his application and lost the key there is additional option of using only locally non-email or non-phone login and with password. After login the key is retrieved and all communication is however based on the key). All your local server is sent or synchronised to the global server - all with this app id in mind - send as is. So if you install or reinstall the app you have many new app ids for each installation. So if a connected device to me try to sent me a message locally but disconnected before he was able to do it? Based on the unique key he connected - you have the key and he has the key - which is stored on global server and using this key on the global server can find his (and he yours) user id and send you messages globally via internet when you lost your local connection. But if you are on different continents and he reinstalled his app - he lost his key and cannot write to you. And it is ok, because those things is to protect your privacy when you are connected locally. However one day an option will be addedd - "store my key using this or these user accounts" - because each app and in effect local server can store more your users, not mentioning lobal and globally connected users. You will be able to see the keys with maybe some descriptions and restore the local user. But it is for a more distant future. We said about the global earthwide server with fixed ip or domain. However remember that technically your app that as you know has its local server is also a global server (this second aspect of your server). So if your settings or firewall allows it then any user on the earth can set up non-default global server which can be your smartphone/device and register using this time only e-mail or phonenumber which will be verified and password. So it is different to login locally using the key or in order to retrieve the lost key using local (!) non-email login/phone number and password - all was already said so it is repeated for making it clear.  
So to send a text message to any user on the global server (the second aspect of any server) you always need your app key got from the server so that the server finds the app id and your user id (you don't now it server knows it from global email/phone +password and session) on the server you need to send to a destination user contact id or group id. And (it techically maybe done a little differently - this is just to understand) when you receive the answer to the message the global server on it's part based on the contact settings searches all app ids of the user you got the anwer from (he reinstalled app many times as you know or uses on many defices the same user - so many app ids) it (the server) searches using e-mail and/or phone number - it checks if there is any new message and you fetch one or more if there is any based on timestamps and last update timestamp. Not going into more detail now, because there maybe some stuff to take into account. But this is going to be the overall architecture. 
WARNING, WHEN YOU LOCALLY CONNECT TO A DEVICE THREE SERVERS, NOT TWO WOULD NORMALLY BE INVOLVED, BECAUSE YOU CONNECT TO A DEVICE LIKE TO A GLOBAL SERVER. THINK HOW TO SOLVE IT - PROBABLY YOU HAVE TO USE THEM THREE. FOR TWO SERVERS YOU STORE A MESSAGE THING ON YOUR LOCAL SERVER THEN SEND IT TO THE GLOBAL. FOR THREE YOU STORE ON YOUR LOCAL SERVER SERVER USING THE USER KEY (AS IN ANY CASE) THEN LET'S SAY YOU SEND IT TO THE SECOND DEVICE AND THAT SECOND DEVICE UPDATES IT ON THE GLOBAL SERVER BUT NOT YOUR FIRST DEVICE. THEN IF YOU REINSTALL THE APP AND YOU ARE NOT CONNECTED TO THE SECOND DEVICE YOU FETCH ALL THE DATA FROM THE GLOBAL SERVER BASED ON YOUR KEY, BUT IF YOU ALSO OR ONLY CONNECT FINALLY TO THE SECOND DEVICE YOU ALSO FETCH ALL THE OLD AND NEW DATA FROM THE SECOND DEVICES SERVER. MESSAGES WOULD NEED TO BE MERGED BASED ON UNIQUE MESSAGE KEY WHICH IS LOCAL SERVER CREATED DATE TIMESTAMP (creation_date_timestamp IF NOT MILISECONDS, AT LEAST LESS LIKE MICROSECONDS IF COMPATIBLE WITH ALL PROGRAMMING LANGUAGES ESPECIALLY PHP, JS, DART), BECAUSE NO TWO MESSAGES CAN'T BE CREATED AT THE SAME TIME - YOUR HAVE TO FORCE THAT. BECAUSE YOU HAVE creation_date_timestamp ON YOUR LOCAL SERVER THEN THE SECOND DEVICE HAS TO HAVE THE SAME DATE AND VICE VERSA IF HE SENDS MESSAGE TO YOU LOCALLY YOU TAKE HIS creation_date_timestamp. THEN BY THIS WHEN YOU UPDATE DATA FROM BOTH OR ONE OF THE SERVERS YOU FIND DUPLICATES BY THE AUTHOR'S creation_date_timestamp LOCAL TIMESTAMP. IF TIMESTAM SEEMS NOT TO WORK PROPERLY APP SHOULD REFUSE USING TWO DEVICES CONNECTION, BUT GLOBAL CAN. AND IN THE MEANTIME A MESSAGE MIGHT HAVE CHANGED/BEEN EDITED SO YOU HAVE TO FINALLY COMPARE MESSAGE FROM THE GLOBAL SERVER AND THE SECOND DEVICE PLUS EDITING. BUT BUT! YOU AS I GUESS TAKE INTO ACCOUNT ONLY THE MESSAGE VERSION FROM THE DEVICE BECAUSE IT IS ALWAYS THE NEWEST VERSION. SO FOR USER USING KEY FOR CONNECTION TO LOCAL DEVICE YOU HAVE TO FETCH DATA FROM TWO SOURCES FIRST FROM THE SECOND DEVICE LOCAL SERVER AND SECOND THE GLOBAL - BOTH CONNECTIONS CAN BE UNSTABLE SO YOU NEED TO BE FLEXIBLE AND DO SOME MORE SOPHISTICATED MERGING. THIS IS DEFAULT OPTION - OFCOURSE YOUR AND/OR SECOND DEVICE HAS RIGHT NOT TO UPDATE ANYTHING ON THE GLOBAL SERVER - YOU THEN WON'T GET ANYTHING FROM IT AS REGARD TO A KEY BASED LOCAL USER (ESPECIALLY)

May be not up-to-date this paragraph.
For server packages shelf and sqlite3/"github sqlweb for web/js" (sqlite only) should be completely enough. Much later mysql (with php in mind). With this approach i can write the same code for server/backend and web probably, and then cleanup web from sqlite sqlite3/sqlweb and shelf. Also thanks to sqlite this app is going to be client of a global server, but it will use the same server to serve localy devices/smartphones connected to your smartphone via wi-fi local network (192.x.y.z, etc.) for example. 

==================================================
How to synchronize local server data with the global server. 
We have to use login (to register/login) by e-mail, phone-number, but also a key we are talking about below. You can login by key only for a local server, but the servers are the same
For now focus on one currently logged and front-screen active user of any device. 
There maybe many users on one device/app installations. But one active now.

0. Your local server works the same as the global one, someone may register normally, 
    but below WE FOCUS ON A TWO DEVICES CONNECTED TO YOUR SERVER BY YOUR PHONE ROUTER OR BY F.E. BLUETOOTH, YOU HAVE TO DETECT THAT SOMEONE CONNECTED TO YOU HAS YOUR LOCAL IP 192.... AND NOT GLOBAL IP NOR DIDN'T WENT FROM OUTSIDE I HE ARRIVED FROM OUTSIDE YOUR LOCAL SERVER HE/SHE CAN REGISTER NORMALLY - ALL YET TO BE PRECISELY FIGURED OUT - YOU WOLD LIKE TO HAVE CONTROL ABOUT OUTSIDE INFLUX, ESPECIALLY BY A SWITCH FOR THE SERVER IN THE FRONTENT-APP VERSION. WEB IS TO WORK THE SAME AS NATIVE APPS IN THIS THAT IT USES AS NATIVE ALSO CAN A FULL-FEATURED COMPATIBLE EMULATION OF THE LOCAL SERVER - AT SOME POINT IN TIME THERE CAN BE SITUATIONS LIKE COMMUNICATION BETWEEN TABS OF THE SAME BROWSER OR ANYTHING ELSE I HAVEN'T THOUGHT OF YET.

1. We went offline, app just has been installed. Local application server just started - it is to work fully like default global but it's local.
2. We are registered globally but the app yet doesn't know of it. We are offline.
3. So we create a user on login and password like for global.
4. New user created. We are waiting to go online.

5. An outside device different person/user connects to our device. That second user request to login. Introduces himself name, surname.
6. We cannot confirm the global identity of the user - he/she may also be offline/unregistered on global server whatever. We are still offline.
7. For now the second user creates unique big safe random key and stores it. The key is permanently attached to the user.
8. You allow him in and register the user on your local server using the key. 
9. However your contact list "don't know" yet about this user so for now also the user is also added to your contact list automatically. If it is removed from you contact list he as the rest of all your local server users however stay for now and should be managed separately. Why - because your app with local server may fulfill the same function as global server so it may be important to remove users carefully. Sometimes information users store can be vital.

10. You and the second user went online and logged in or registered you users using the login and password used when you were offline or one of you used different login and password. Finally you both are logged in globally not necessary at the same time.
11. The user sends to the global server the key that is used by him and you on your local server (to a table with one or more keys attached to a given user_id)
12. Now we have to be careful. You just get the server user_id and you cannot loose it, the user_id based on the key which is enough, but later the ever more fancier version of the app probably have to ask for email, login, or both, it seems however that he/she can decline the request.

13. Having this we can focus on sending the data to the server but it is still tricky - the user may yet have not sent our well-known key to the server
-- let's rest a bit.

=================================================

Technical to do: 
i've panicked a little, but maybe it is not that difficult, i "panicked" again when you have one user on two or more devices both went offline for couple of days and are quite different in many aspects - YOU AS USER OF THE APP EXPECT ALL THE MESS WILL BE SORTED OUT SOMEHOW, RIGHT?:
To simplify you installed your app logged and you are a user with long history of f.e. contacts, groups, chats, but also tasks, etc - let's focus on less not to get confused:
1. You load your contacts/messages data from the server.
2. You went offline for whatever time hour, day, week, month, even three months - you have job online in a rainforest in central america with no access to the internet but you have your solar usb powerbank.
3. You do some offline changes.
For now: You cannot update anything FROM the server, first you have to send your changes to the server with timestamp you last was online and server must know it (statistically more reliable way later - time on the phone must be properly synchronized - this later). For now the date on the server is more important, and easier. PROBABLY THE LAST TIMESTAMP IS ABOUT LAST TIME DATA WAS FULLY SYNCHRONIZED - SO IF YOU SEND CHANGES FROM 1 WIDGET OR 10 IN CHUNKS ALL NEED HAVE THE SAME LAST TIMESTAMP DATA. ONLY AFTER YOU SENT/SYNCHRONIZED !!ALL!! YOU CAN UPDATE THE TIME STAMP THE APP MUST INFORM SYNCHRONIZATION FINISHED AND SERVER CHANGES THE TIMESTAMP TO A NEWER. IN THE MEANTIME YOU HAD A SLOW INTERNET CONNECTION AND MADE SOME CHANGES YOU CANNOT SEND THEM FOR NOW, NOW IS TIME TO UPDATE DATA FROM THE  
Older explanation, overal Better solution:
I HAVE NOW AN IDEA YOU UPDATE YOUR LAST ONLINE TIMESTAMP FROM THE SERVER, AND ALL NEW MESSAGES, CONTACTS IN THE TIME OFFLINE GET THE OLD TIMESTAMP. !!! THIS TIME SERVER KNOWS, FOR THIS YOU MUST
USE UNIQUE ID OF THE APP SOME RANDOM UGLY NUMBER - IT MAYBE QUITE SIMPLE TO DO !!! I THINK THE EASIEST WAY TO DO IT WHEN YOU GO OFFLINE IS F.E. ALL MESSAGES, NEW CONTACTS, WIDGET MOVEMENTS GET LASTSEEN/LASTCONTACTTOTHESERVER TIMESTAMP COMING FROM THE SERVER. SO WIDGET CAN BE UPDATED ON THE SERVER IN THIS WAY I HAVE THE TIMESTAMP FROM ONE HOUR AGO - ALL MY NEW WIDGETS GET THIS DATE, BUT IF SOMETHING WAS REMOVED, MOVED HALF AN HOUR ON THE SERVER BY THE OTHER INSTANCE OF THE APP, BY THE SAME USER (NOT ONLY IN CONTACT GROUPS) THE SECOND APP GET PRIORITY, AND AS I WRITE IT LATER IT CAN BE MOVED TO THE ARCHIVE IN THE APP NOT ON THE SERVER PROBABLY AND OR MARKED AS REMOVED IN THE APP IN THE PLACE IT WAS ORIGINALLY - MAYBE not because TOO CONFUSING
4. Now you get the uptodate tree of ids of models/widgets from the server but ids with the timestamps i think, and the tree is the main thing now with which the rest is to be compared with, it is final i think. And you could build a new tree of models based on that tree of ids from the server and you have to decide which widget from the server is up-to-date - you need to compare a widget last update on the server timestamp (the same maing group update timestamp from the previous point) with the timestamp assigned to the mentioned id. If the timestamp received from the server is newer - another instance of the app with the same user, o possibly another user from the contact group changed the widget after you and it must be updated. By the way if it is a browser the tree of ids from the server should go to localStorage. After reload you get the up-to-date data from the server anyway. It can be a little more difficult, but it seems to be close to be solved.
5. The 4. point is more important, you analyse how it relates to it. If element was removed (not the same as moved) in the meantime on the server by another instance of the same user on other device you mark it as removed in the app but you don't remove it from the app you inform it's been removed and alow for sending to archive/trash in the app (i know it is the same user), additionaly you alow to do it massively all such items. You do overall warning - data no longer available it may be lost.
6. The 4. point is more important, you analyse how it relates to it. If element was moved not removed by the second instance of the app you seek
First you always update your changes on the server g

Each coding start repeating this (if i am correct). Both methods then and catchError of [Future] object .object.then produces another and brand new (second) future object. When you in then pass the callback and the callback return some value, the second future is finished with that value, you have then(() {return firstvalue}).then((firstvalue) {whatever}) - alright for now? The point: So based on the aforementioned i assume that then(() {return firstvalue}).catchError().catchError().then((firstvalue) {whatever}) - it works this way if NO error occured and knowing that each method produces a new [Future] first then copletes the second Future it produced, next catchError internally/invisibly completes the third Future with the mentioned "return firstvalue", next catchError the fourth Future also with the same "return firstvalue", and our second then() is completed with the firstvalue .then((firstvalue) {whatever}). So catchError must be constructed that it conveys the firstvalue of the first then passing finally to the sedon then. Again it is only done by completing Futures they created one by one. So in total we have probably 5 Futures but 4 Futures completed in total until we invoke our part "(firstvalue) {whatever}". I think it cannot work any other way.

Condition is (going to be) a messenger with audio and video (+ conference), a task manager, a fittness app, an some feateres more.

Replace Hive or shared_preferences with your own simple (simple !) key-value solution based on files and localstorage for web - strings only, not maps, integers - right? - ConditionModel models are to do the rest with types and even sofisticated pseudo types.

This for now is going to be optimised for a max middle size number of user in one backend server.
It could be like 10000 users without video and like 200 users for video one conference on the server.
To achieve greater numbers, being rather designed for a standalone powerful server with 2 to 5 Gbits bandwdth gigabits you could achieve up to 1000 video users in pretty good video quality or 2000 in a worse but about 10000 in barely enough quality

This app is done with all platforms in mind, even old handsets, on all desktops, android, ios, BUT finally also on dart commandline (+ nodejs after dartjs), when one dart <command> invokation gives you sending a message, contact list etc. For this you need f.e. Hive plugin not shared_preferences. On web using url should enable you getting a widget, put some data send message if you are logged, etc. Also url should enable you reading data from a frame, f.e a message, that appeared after changing url in the frame. So all-flexible solution.


[To do]
Now i think the app/frontend data architecture would be like this on all platforms to make one code for all but from web perspective and you implement the equivalent for all:
1. You load all data (tree of widgets) from json which is in a div. THIS WILL BE IN MEMORY SO ONLY LIMITED NUMBER OF WIDGETS WILL BE IN THE DIV AND THERE WILL BE A MANAGER FOR THAT - LATER ON THE REST OF THE WIDTETS. If possible a page should be reloaded from cache. Also you could save the page offline and open it in a browser and see it's working - i know it can be done if data is in div. At this point LocalStorage isn't used.

2. LocalStorage (important: much is described also for [ConditionModelId] class description). After loading the app changes are made offline adding to the stack of changes in LocalStorage. How? At the beginning you have the standard tree of models and another tree which fully mirrors the original one in a way that it contains empty widget models and also containing changed normal widget models. So if you have [ConditionModelMessage] model, if it wasn't updated, in the second tree it will have just widget id, so in case of widgets were sorted you have in LocalStorage only simple updated json encoded widget numbers. But if in such an id you stumble upon [ConditionModelMessage] json fully serialized widget it means a widget was added or changed. 
So what do you have to do - you have LocalStorage updated shortened/simplified but full actual/updated tree of just ids models [ConditionModelId] or typical models class like [ConditionModelMessage]. you traverse the tree looking a widget (id) in the original full tree of models and link the actual model with the model found there. Now we have the updated full tree of models which we can render. Being offline If a widget is updated or added we immediatelly update the second tree in the LocalStorage, then try synchronising it also on the server. The server will send full json of the first main tree on full reload to the div from point "1.". But only after full synchronization a full reload can clean up the LocalStorage from changes. This doesn't take into account conflicts caused by different instances of the app (newest update is more important).
3. Let say we are offline all the time after the first app loading. We refresh the page. We get widget tree (model tree) from that div in point "1." . Then we restore all the changes sequently one by one from the localStorage ad they were done, adding new models or updating the existing models. In the model Tree. (much is described also for [ConditionModelId] class description)
4. We get online. We update synchroinize the data on the server in one request in a way that no update/add operation on the server can fail - which seems that to be easier for now to send all the changed models of the changed widgets, and add new widgets. After ALL is fully synchronized, we cannot remove anything from LocalStorage only after all the page is sent from the server with full json in the div from point "1.". So for now it seems that a page should be reloaded automatically in a moment of inactivity (but when LocalStorage gets close to be full) i a way that a possibly edited current widget is saved in the current state. A user should be informed that in order for application to work properly we need to reload but the edited widget itself should be yet stored. Such thing shouldn't happen when you don't store images in LocalStorage - only teksts and textual configuration.

At the BEGINNING all platform work the same but:
For web you FINALLY need to take data from div when the page is loaded and try to cashe webpages with this div placed in html. When a app/page is loaded from cashe it will use the data as a starting point instead of using LocalStorage, and then the empty LocalStorage could be used only for new data that possibly cannot be synchronizded because of lack of internet access, the data from localStorage would be restored after another load from cache - because we imagine scenario of loading page from cashe a couple of times until there is internet access. But for desktop, android you can store everything normally and don't care much for now.

The architecture is data Models (they are Maps at the same time (based on MapDelegate class)) handled in a tree can be json encoded. Each model has it's own coresponding widget in a property of the model, having all the tree model you can crete and render widgets going down the model tree one by one. So after login you first simply recreate all models tree then one by one create widgets reflecting the model tree. SO USER SHOULD BE AT THE TOP OF THE TREE AND OBVIOUSLY IT WOULDN'T HAVE ANY WIDGET ATTACHED TO ITSELF LIKE IN CASE OF THOSE WIDGET MODELS

Knowing this /// The important part of the tree starts with a Stateful widget [ConditionUser], this widget along with each relevant widget of the architecture has its model and basically represends part of a layout. Then you have (not done yet) about 10 tabs and coresponding classes which are layout by [ConditionUser], however i suppose they don't neccessaryli need any models attached to them they can be managed via [ConditionUser], then you have in each of the 10 tabs [ConditionDragTargetContainerWidget] widgets each coresponding tab f.e. any messenger message [ConditionMessage] widget (extending [ConditionDragTargetContainerWidget]) with a correponsing data model [ConditionModelMessage], the widget will be rendered in one of the 10 tabs in a tab it is meant to be. For this it is probably enough to have a [ConditionModelUser] model which is a [Map] easily converted to json, a map with additional features and a mentioned widget instance attached to the [ConditionModelUser] map. Simplifying then you have in the [ConditionModelUser] a list where each element of the list corresponds to a tab, and an example tab will have f.e [ConditionMessageModel] elements in the right order. Any [ConditionMessageModel] widget can have f.e. answers to a message so can have one or more [ConditionMessageModel] widgets in itself. If you got it so far, the benefit of such an architecture is. Because ol Model are map you can very easily serialise [toString] or [jsonEncode] first [ConditionModelUser] and it will give you full deep tree of the models with [ConditionMessageModel] messages and its submessages. So the top [ConditionUser] widget will take care of traversing through the tree of all the models and their corresponding widgets, will render them assigning to the corresponding tabs. This architecture seems to be the fastest. It would be easier to implement if each widget was kind of intependent from it's parent in terms of data and confituration. And as you guess you can have more than [ConditionUser] at the same time and copy or link our example [ConditionModelMessage] message not only withing the same tab or other tabs of the same user but even between currently logged users in the application. So when you update a property of the model f.e. model.title = 'title' a setter will do model['title']=
Knowing this /// The important part of the tree starts with a Stateful widget [ConditionUser], this widget along with each relevant widget of the architecture has its model and basically represends part of a layout. Then you have (not done yet) about 10 tabs and coresponding classes which are layout by [ConditionUser], however i suppose they don't neccessaryli need any models attached to them they can be managed via [ConditionUser], then you have in each of the 10 tabs [ConditionDragTargetContainerWidget] widgets each coresponding tab f.e. any messenger message [ConditionMessage] widget (extending [ConditionDragTargetContainerWidget]) with a correponsing data model [ConditionModelMessage], the widget will be rendered in one of the 10 tabs in a tab it is meant to be. For this it is probably enough to have a [ConditionModelUser] model which is a [Map] easily converted to json, a map with additional features and a mentioned widget instance attached to the [ConditionModelUser] map. Simplifying then you have in the [ConditionModelUser] a list where each element of the list corresponds to a tab, and an example tab will have f.e [ConditionMessageModel] elements in the right order. Any [ConditionMessageModel] widget can have f.e. answers to a message so can have one or more [ConditionMessageModel] widgets in itself. If you got it so far, the benefit of such an architecture is. Because ol Model are map you can very easily serialise [toString] or [jsonEncode] first [ConditionModelUser] and it will give you full deep tree of the models with [ConditionMessageModel] messages and its submessages. So the top [ConditionUser] widget will take care of traversing through the tree of all the models and their corresponding widgets, will render them assigning to the corresponding tabs. This architecture seems to be the fastest. It would be easier to implement if each widget was kind of intependent from it's parent in terms of data and confituration. And as you guess you can have more than [ConditionUser] at the same time and copy or link our example [ConditionModelMessage] message not only withing the same tab or other tabs of the same user but even between currently logged users in the application. So when you update a property of the model f.e. model.title = 'title' a setter will do model\['title'\]= title (from the param of the setter), but the models widget will be updated (setState()) with the new title and it's subwidgets down the tree will be traversed which according to what i know, they probably will not change because of the mere title change of their ancestor widget, so it won't be resources consuming.


For the web bigger overhead size is better than limitation in the amount of data that can be stored. So improving data compression methods or some custom encoding is ok.

To developers. During development have in mind of doing in javascript, not dart some improvements for web, especially Local storate data compression due to browser limitation of 5 MB stored data. As far as i remember someone said that changing encoding from 2 bytes to 1 byte would give you even 10 MB data - i don't know how because 5 MB is 5 MB. It looks like it should mean that 2 bytes encoding would give you 2,5 MB of test if you are not using one byte encoding.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://flutter.dev/docs/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://flutter.dev/docs/cookbook)

For help getting started with Flutter, view our
[online documentation](https://flutter.dev/docs), which offers tutorials,
samples, guidance on mobile development, and a full API reference.
